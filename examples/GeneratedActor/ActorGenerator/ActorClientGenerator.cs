using System.Diagnostics;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace ActorGenerator;

[Generator]
public sealed class ActorClientGenerator : ISourceGenerator
{
    private sealed class ActorInterfaceSyntaxReceiver : ISyntaxContextReceiver
    {
        private readonly List<InterfaceDeclarationSyntax> models = new();

        public IEnumerable<InterfaceDeclarationSyntax> Models => this.models;

        #region ISyntaxContextReceiver Members

        public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
        {
            if (context.Node is not InterfaceDeclarationSyntax interfaceDeclarationSyntax || interfaceDeclarationSyntax.BaseList is null)
            {
                return;
            }

            // TODO: Better qualify the IActor check.
            if (interfaceDeclarationSyntax.BaseList.Types.Any(t => t.Type.ToString() == "IActor"))
            {
                this.models.Add(interfaceDeclarationSyntax);
            }
        }

        #endregion
    }

    #region ISourceGenerator Members

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxContextReceiver is not ActorInterfaceSyntaxReceiver actorInterfaceSyntaxReceiver)
        {
            return;
        }

        foreach (var model in actorInterfaceSyntaxReceiver.Models)
        {
            var semanticModel = context.Compilation.GetSemanticModel(model.SyntaxTree);
            var symbol = semanticModel.GetDeclaredSymbol(model);

            if (symbol is null)
            {
                continue;
            }

            var actorInterfaceTypeName = symbol.Name;
            var fullyQualifiedActorInterfaceTypeName = symbol.ToString();

            var source = $@"// <auto-generated/>
using Dapr.Actors;
using Dapr.Actors.Client;

namespace {"bar"}
{{
    public sealed class {actorInterfaceTypeName}ManualProxy : {fullyQualifiedActorInterfaceTypeName}
    {{
        private readonly ActorProxy actorProxy;

        public {actorInterfaceTypeName}ManualProxy(ActorProxy actorProxy)
        {{
            this.actorProxy = actorProxy;
        }}
    }}
}}
";
            // Add the source code to the compilation
            context.AddSource($"{actorInterfaceTypeName}.g.cs", source);
        }
    }

    public void Initialize(GeneratorInitializationContext context)
    {
        while (!Debugger.IsAttached)
        {
            System.Threading.Thread.Sleep(500);
        }

        context.RegisterForSyntaxNotifications(() => new ActorInterfaceSyntaxReceiver());
    }

    #endregion
}