using System.Diagnostics;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace ActorGenerator;

/// <summary>
/// Generates strongly-typed actor clients that use the non-remoting actor proxy.
/// </summary>
[Generator]
public sealed class ActorClientGenerator : ISourceGenerator
{
    private const string GeneratorsNamespace = "Dapr.Actors.Generators";

    private const string ActorMethodAttributeTypeName = "ActorMethodAttribute";
    private const string ActorMethodAttributeFullTypeName = GeneratorsNamespace + "." + ActorMethodAttributeTypeName;

    private const string GenerateActorClientAttribute = "GenerateActorClientAttribute";
    private const string GenerateActorClientAttributeFullTypeName = GeneratorsNamespace + "." + GenerateActorClientAttribute;

    private const string ActorMethodAttributeText = $@"
        #nullable enable

        namespace {GeneratorsNamespace}
        {{
            [AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
            internal sealed class ActorMethodAttribute : Attribute
            {{
                public string? Name {{ get; set; }}
            }}
        }}";

    private const string GenerateActorClientAttributeText = $@"
        #nullable enable

        namespace {GeneratorsNamespace}
        {{
            [AttributeUsage(AttributeTargets.Interface, AllowMultiple = false, Inherited = false)]
            internal sealed class GenerateActorClientAttribute : Attribute
            {{
                public string? Name {{ get; set; }}

                public string? Namespace {{ get; set; }}
            }}
        }}";

    private sealed class ActorInterfaceSyntaxReceiver : ISyntaxContextReceiver
    {
        private readonly List<INamedTypeSymbol> models = new();

        public IEnumerable<INamedTypeSymbol> Models => this.models;

        #region ISyntaxContextReceiver Members

        public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
        {
            if (context.Node is not InterfaceDeclarationSyntax interfaceDeclarationSyntax
                || interfaceDeclarationSyntax.AttributeLists.Count == 0)
            {
                return;
            }

            var interfaceSymbol = context.SemanticModel.GetDeclaredSymbol(interfaceDeclarationSyntax) as INamedTypeSymbol;

            if (interfaceSymbol is null
                || !interfaceSymbol.GetAttributes().Any(a => a.AttributeClass?.ToString() == GenerateActorClientAttributeFullTypeName))
            {
                return;
            }

            this.models.Add(interfaceSymbol);
        }

        #endregion
    }

    #region ISourceGenerator Members

    /// <inheritdoc />
    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxContextReceiver is not ActorInterfaceSyntaxReceiver actorInterfaceSyntaxReceiver)
        {
            return;
        }

        var actorMethodAttributeSymbol = context.Compilation.GetTypeByMetadataName(ActorMethodAttributeFullTypeName) ?? throw new InvalidOperationException("Could not find ActorMethodAttribute.");
        var generateActorClientAttributeSymbol = context.Compilation.GetTypeByMetadataName(GenerateActorClientAttributeFullTypeName) ?? throw new InvalidOperationException("Could not find GenerateActorClientAttribute.");

        foreach (var interfaceSymbol in actorInterfaceSyntaxReceiver.Models)
        {
            var actorInterfaceTypeName = interfaceSymbol.Name;
            var fullyQualifiedActorInterfaceTypeName = interfaceSymbol.ToString();

            var attributeData = interfaceSymbol.GetAttributes().Single(a => a.AttributeClass?.Equals(generateActorClientAttributeSymbol, SymbolEqualityComparer.Default) == true);

            var accessibility = GetClientAccessibility(interfaceSymbol);
            var clientTypeName = GetClientName(interfaceSymbol, attributeData);
            var namespaceName = attributeData.NamedArguments.SingleOrDefault(kvp => kvp.Key == "Namespace").Value.Value?.ToString() ?? interfaceSymbol.ContainingNamespace.ToDisplayString();

            var members = interfaceSymbol.GetMembers().OfType<IMethodSymbol>().Where(m => m.MethodKind == MethodKind.Ordinary).ToList();

            var methodImplementations = String.Join("\n", members.Select(member => GenerateMethodImplementation(member, actorMethodAttributeSymbol)));

            var source = $@"// <auto-generated/>
using Dapr.Actors;
using Dapr.Actors.Client;

namespace {namespaceName}
{{
    {accessibility} sealed class {clientTypeName} : {fullyQualifiedActorInterfaceTypeName}
    {{
        private readonly ActorProxy actorProxy;

        public {clientTypeName}(ActorProxy actorProxy)
        {{
            this.actorProxy = actorProxy;
        }}

        {methodImplementations}
    }}
}}
";
            // Add the source code to the compilation
            context.AddSource($"{actorInterfaceTypeName}.g.cs", source);
        }
    }

    /// <inheritdoc />
    public void Initialize(GeneratorInitializationContext context)
    {
        /*
        while (!Debugger.IsAttached)
        {
            System.Threading.Thread.Sleep(500);
        }
        */

        context.RegisterForPostInitialization(
            i =>
            {
                i.AddSource($"{ActorMethodAttributeFullTypeName}.g.cs", ActorMethodAttributeText);
                i.AddSource($"{GenerateActorClientAttributeFullTypeName}.g.cs", GenerateActorClientAttributeText);
            });

        context.RegisterForSyntaxNotifications(() => new ActorInterfaceSyntaxReceiver());
    }

    #endregion

    private static string GetClientAccessibility(INamedTypeSymbol interfaceSymbol)
    {
        return interfaceSymbol.DeclaredAccessibility switch
        {
            Accessibility.Public => "public",
            Accessibility.Internal => "internal",
            Accessibility.Private => "private",
            Accessibility.Protected => "protected",
            Accessibility.ProtectedAndInternal => "protected internal",
            _ => throw new InvalidOperationException("Unexpected accessibility.")
        };
    }

    private static string GetClientName(INamedTypeSymbol interfaceSymbol, AttributeData attributeData)
    {
        string? clientName = attributeData.NamedArguments.SingleOrDefault(kvp => kvp.Key == "Name").Value.Value?.ToString();
        
        clientName ??= $"{(interfaceSymbol.Name.StartsWith("I") ? interfaceSymbol.Name.Substring(1) : interfaceSymbol.Name)}Client";

        return clientName;
    }

    private static string GenerateMethodImplementation(IMethodSymbol method, INamedTypeSymbol generateActorClientAttributeSymbol)
    {
        var returnType = method.ReturnType as INamedTypeSymbol;

        if (returnType is null)
        {
            // TODO: Return a diagnostic instead.
            throw new InvalidOperationException("Return type is not a named type symbol.");
        }

        if (method.Parameters.Length > 1)
        {
            throw new InvalidOperationException("Too many parameters.");
        }

        var attributeData = method.GetAttributes().SingleOrDefault(a => a.AttributeClass?.Equals(generateActorClientAttributeSymbol, SymbolEqualityComparer.Default) == true);

        string methodName = method.Name;

        string? actualMethodName = attributeData?.NamedArguments.SingleOrDefault(kvp => kvp.Key == "Name").Value.Value?.ToString();
        
        actualMethodName ??= methodName;

        var parameterType = method.Parameters.FirstOrDefault();

        var returnTypeArgument = returnType.TypeArguments.FirstOrDefault();

        if (returnTypeArgument is not null && parameterType is not null)
        {
            return $@"
            public {returnType} {methodName}({parameterType.Type} {parameterType.Name})
            {{
                return this.actorProxy.InvokeMethodAsync<{parameterType.Type}, {returnTypeArgument}>(""{actualMethodName}"", {parameterType.Name});
            }}
            ";
        }
        else if (returnTypeArgument is null && parameterType is null)
        {
            return $@"
            public {returnType} {methodName}()
            {{
                return this.actorProxy.InvokeMethodAsync(""{actualMethodName}"");
            }}
            ";
        }
        else if (returnTypeArgument is null && parameterType is not null)
        {
            return $@"
            public {returnType} {methodName}({parameterType.Type} {parameterType.Name})
            {{
                return this.actorProxy.InvokeMethodAsync(""{actualMethodName}"", {parameterType.Name});
            }}
            ";
        }
        else if (returnTypeArgument is not null && parameterType is null)
        {
            return $@"
            public {returnType} {methodName}()
            {{
                return this.actorProxy.InvokeMethodAsync<{returnTypeArgument}>(""{actualMethodName}"");
            }}
            ";
        }
        else
        {
            throw new InvalidOperationException("Unexpected case.");
        }
    }
}