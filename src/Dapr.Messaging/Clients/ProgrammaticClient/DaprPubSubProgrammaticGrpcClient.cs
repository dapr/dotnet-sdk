// ------------------------------------------------------------------------
//  Copyright 2025 The Dapr Authors
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//      http://www.apache.org/licenses/LICENSE-2.0
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//  ------------------------------------------------------------------------

using System.Text.Json;
using Dapr.Common;
using Dapr.Common.Serialization;
using Dapr.Messaging.Clients.StreamingClient;
using Dapr.Messaging.PublishSubscribe;
using Google.Protobuf;
using Grpc.Core;
using Autogenerated = Dapr.Client.Autogen.Grpc.v1;

namespace Dapr.Messaging.Clients.ProgrammaticClient;

/// <summary>
/// A client for interacting with the Dapr endpoints.
/// </summary>
internal sealed class DaprPubSubProgrammaticGrpcClient(
    Autogenerated.Dapr.DaprClient client,
    HttpClient httpClient,
    JsonSerializerOptions jsonSerializerOptions,
    string? daprApiToken = null) : DaprPubSubProgrammaticClient(client, httpClient, jsonSerializerOptions, daprApiToken)
{
    /// <inheritdoc/>
    public override async Task PublishEventAsync<TData>(
        string pubSubName,
        string topicName,
        TData? data = null,
        Dictionary<string, string>? metadata = null,
        CancellationToken cancellationToken = default) where TData : class
    {
        ArgumentException.ThrowIfNullOrEmpty(pubSubName, nameof(pubSubName));
        ArgumentException.ThrowIfNullOrEmpty(topicName, nameof(topicName));

        var payload = data is null ? null : TypeConverters.ToJsonByteString(data, JsonSerializerOptions);
        await MakePublishRequestAsync(pubSubName, topicName, payload, cancellationToken: cancellationToken);
    }

    /// <inheritdoc/>
    public override async Task PublishEventAsync<TData>(
        string pubSubName,
        string topicName,
        IReadOnlyList<TData> data,
        Dictionary<string, string>? metadata = null,
        CancellationToken cancellationToken = default)
    {
        ArgumentException.ThrowIfNullOrEmpty(pubSubName, nameof(pubSubName));
        ArgumentException.ThrowIfNullOrEmpty(topicName, nameof(topicName));

        var payload = TypeConverters.ToJsonByteString(data, JsonSerializerOptions);
        await MakePublishRequestAsync(pubSubName, topicName, payload, cancellationToken: cancellationToken);
    }

    /// <inheritdoc/>
    public override async Task PublishEventAsync(
        string pubSubName,
        string topicName,
        ReadOnlyMemory<byte> data,
        string dataContentType = "application/json",
        Dictionary<string, string>? metadata = null,
        CancellationToken cancellationToken = default)
    {
        ArgumentException.ThrowIfNullOrEmpty(pubSubName, nameof(pubSubName));
        ArgumentException.ThrowIfNullOrEmpty(topicName, nameof(topicName));
        
        await MakePublishRequestAsync(pubSubName, topicName, ByteString.CopyFrom(data.Span), dataContentType, metadata,
            cancellationToken);
    }
    
    /// <inheritdoc/>
    public override Task<DaprBulkPublishResponse> BulkPublishEventAsync<TValue>(
        string pubsubName,
        string topicName,
        IReadOnlyList<TValue> events,
        Dictionary<string, string>? metadata = null,
        CancellationToken cancellationToken = default)
    {
        ArgumentVerifier.ThrowIfNullOrEmpty(pubsubName, nameof(pubsubName));
        ArgumentVerifier.ThrowIfNullOrEmpty(topicName, nameof(topicName));
        ArgumentVerifier.ThrowIfNull(events, nameof(events));
        var pubSubEvents = events
            .Select(ev => new DaprBulkPublishRequest<TValue>(ev))
            .ToList();

        return MakePublishRequestAsync(pubsubName, topicName, pubSubEvents, metadata, cancellationToken);
    }

    private async Task MakePublishRequestAsync(
        string pubSubName,
        string topicName,
        ByteString? payload = null,
        string? dataContentType = null,
        Dictionary<string, string>? metadata = null,
        CancellationToken cancellationToken = default)
    {
        var envelope = new Autogenerated.PublishEventRequest { PubsubName = pubSubName, Topic = topicName };

        if (payload is not null)
        {
            envelope.Data = payload;
            envelope.DataContentType = dataContentType;
        }

        if (metadata is not null)
        {
            foreach (var kvp in metadata)
            {
                envelope.Metadata.Add(kvp.Key, kvp.Value);
            }
        }

        var grpcCallOptions =
            DaprClientUtilities.ConfigureGrpcCallOptions(typeof(DaprPubSubStreamingGrpcClient).Assembly, DaprApiToken,
                cancellationToken);

        try
        {
            await Client.PublishEventAsync(envelope, grpcCallOptions);
        }
        catch (RpcException ex)
        {
            throw new DaprException(
                "Publish operation failed: the Dapr endpoint indicated a failure. See InnerException for details.", ex);
        }
    }
    
    private async Task<DaprBulkPublishResponse> MakePublishRequestAsync<T>(
        string pubSubName,
        string topicName,
        IReadOnlyList<DaprBulkPublishRequest<T>> events,
        Dictionary<string, string>? metadata = null,
        CancellationToken cancellationToken = default)
    {
        var envelope = new Autogenerated.BulkPublishRequest { PubsubName = pubSubName, Topic = topicName };
        var entryMap = new Dictionary<string, Autogenerated.BulkPublishRequestEntry>();

        for (var counter = 0; counter < events.Count; counter++)
        {
            var entry = new Autogenerated.BulkPublishRequestEntry
            {
                EntryId = counter.ToString(),
                Event = TypeConverters.ToJsonByteString(events[counter], JsonSerializerOptions),
                ContentType = events[counter].DataContentType
            };
            
            //Add the metadata to each entry
            if (metadata is not null)
            {
                foreach (var kvp in metadata)
                {
                    entry.Metadata.Add(kvp.Key, kvp.Value);
                }
            }
            envelope.Entries.Add(entry);
            entryMap.Add(counter.ToString(), entry);
        }
        
        //Add the metadata to the outer request as well
        if (metadata is not null)
        {
            foreach (var kvp in metadata)
            {
                envelope.Metadata.Add(kvp.Key, kvp.Value);
            }
        }

        var grpcCallOptions =
            DaprClientUtilities.ConfigureGrpcCallOptions(typeof(DaprPubSubStreamingGrpcClient).Assembly, DaprApiToken,
                cancellationToken);
        try
        {
            var response = await Client.BulkPublishEventAlpha1Async(envelope, grpcCallOptions);

            var bulkPublishResponse = new DaprBulkPublishResponse(response.FailedEntries
                .Select(entry => new DaprBulkPublishResponseFailedEntry(entryMap[entry.EntryId], entry.Error))
                .ToList());
            return bulkPublishResponse;
        }
        catch (RpcException ex)
        {
            throw new DaprException(
                "Publish operation failed: the Dapr endpoint indicated a failure. See InnerException for details.", ex);
        }
    }
}
